<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"xzhzzz.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.14.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="...">
<meta property="og:url" content="https://xzhzzz.github.io/page/3/index.html">
<meta property="og:site_name" content="...">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="xzhzzz">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://xzhzzz.github.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>...</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">...</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">to the moon</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">xzhzzz</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xzhzzz.github.io/2019/03/17/chrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xzhzzz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="...">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ...">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/03/17/chrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">chrome插件开发</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-03-17 20:15:27" itemprop="dateCreated datePublished" datetime="2019-03-17T20:15:27+08:00">2019-03-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-16 16:38:36" itemprop="dateModified" datetime="2022-12-16T16:38:36+08:00">2022-12-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是Chrome插件"><a href="#什么是Chrome插件" class="headerlink" title="什么是Chrome插件"></a>什么是Chrome插件</h2><p>Chrome插件是一个用Web技术开发、用来增强浏览器功能的软件，它其实就是一个由HTML、CSS、JS、图片等资源组成的一个<code>.crx</code>后缀的压缩包。</p>
<h2 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h2><p>Chrome插件开发只需保证项目的根目录有一个<code>manifest.json</code>的配置文件即可。</p>
<p>下面是这个插件demo的项目结构。里面包含了已经打包的扩展程序的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── chrome-plg-movierank.crx      // chrome打包后的插件包</span><br><span class="line">├── chrome-plg-movierank.pem      // chrome导入插件后生成的密钥</span><br><span class="line">├── index.html                    // 插件的html入口文件</span><br><span class="line">├── index.css                     // 插件的css文件</span><br><span class="line">├── index.js                      // 插件的js文件</span><br><span class="line">├── logo.png                      // 插件的logo</span><br><span class="line">├── manifest.json                 // 插件配置文件</span><br></pre></td></tr></table></figure>

<h3 id="manifest-json"><a href="#manifest-json" class="headerlink" title="manifest.json"></a>manifest.json</h3><p>下面是一个简单的demo配置文件，详细的配置文档可以参考<a target="_blank" rel="noopener" href="https://developer.chrome.com/extensions/manifest">官方文档（需自备梯子）</a>。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;manifest_version&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="comment">// 用于定义配置版本，必须为2</span></span><br><span class="line">	<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;票房排行榜&quot;</span><span class="punctuation">,</span> <span class="comment">// 插件名称</span></span><br><span class="line">	<span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0&quot;</span><span class="punctuation">,</span> <span class="comment">// 插件版本，用于迭代</span></span><br><span class="line">	<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;实时电影票房排行榜&quot;</span><span class="punctuation">,</span> <span class="comment">// 插件描述</span></span><br><span class="line">	<span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xzhzzz&quot;</span><span class="punctuation">,</span> <span class="comment">// 插件作者名称</span></span><br><span class="line">	<span class="attr">&quot;icons&quot;</span><span class="punctuation">:</span> <span class="comment">// 插件图标</span></span><br><span class="line">	<span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;16&quot;</span><span class="punctuation">:</span> <span class="string">&quot;logo.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;48&quot;</span><span class="punctuation">:</span> <span class="string">&quot;logo.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;128&quot;</span><span class="punctuation">:</span> <span class="string">&quot;logo.png&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;browser_action&quot;</span><span class="punctuation">:</span> <span class="comment">// 浏览器右上角配置</span></span><br><span class="line">	<span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;default_icon&quot;</span><span class="punctuation">:</span> <span class="string">&quot;logo.png&quot;</span><span class="punctuation">,</span> <span class="comment">// 右上角图标展示</span></span><br><span class="line">		<span class="attr">&quot;default_popup&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.html&quot;</span> <span class="comment">// 图标悬停时展示的页面</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 引用第三方资源白名单配置，不配置资源无效</span></span><br><span class="line">  <span class="attr">&quot;content_security_policy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27;;script-src &#x27;self&#x27; &#x27;unsafe-            eval&#x27; https://cdn.bootcss.com; object-src &#x27;self&#x27; ;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>基本上文件配置好后，剩下的就是跟平常开发web页面一样，把内容填充到index.html就行了。</p>
<h3 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h3><p>入口文件，使用了第三方cdn链接vue和axios库</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>实时电影票房排行榜<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vue/2.6.6/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/axios/0.18.0/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./index.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span>&gt;</span>排名<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span>&gt;</span>影片名<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span>&gt;</span>实时票房（万）<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span>&gt;</span>票房占比<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span>&gt;</span>上映天数<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span>&gt;</span>累计票房（万）<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in rankList&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">:title</span>=<span class="string">&quot;item.Irank&quot;</span>&gt;</span>&#123;&#123;item.Irank&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">:title</span>=<span class="string">&quot;item.MovieName&quot;</span>&gt;</span>&#123;&#123;item.MovieName&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">:title</span>=<span class="string">&quot;item.BoxOffice&quot;</span>&gt;</span>&#123;&#123;item.BoxOffice&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">:title</span>=<span class="string">&quot;item.boxPer&quot;</span>&gt;</span>&#123;&#123;item.boxPer&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">:title</span>=<span class="string">&quot;item.movieDay&quot;</span>&gt;</span>&#123;&#123;item.movieDay === &#x27;0&#x27; ? &#x27;-&#x27; : item.movieDay&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">:title</span>=<span class="string">&quot;item.sumBoxOffice&quot;</span>&gt;</span>&#123;&#123;item.sumBoxOffice === &#x27;0.00&#x27; ? &#x27;-&#x27; : item.sumBoxOffice&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="index-css"><a href="#index-css" class="headerlink" title="index.css"></a>index.css</h3><p>用css简单的处理一下布局</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#app</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">540px</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">240px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">90px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">    <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h3><p>使用axios库请求第三方接口获取排行榜数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">rankList</span>: &#123;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getMovieData</span>()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="title function_">getMovieData</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="title function_">axios</span>(&#123;</span><br><span class="line">                <span class="attr">methos</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">                <span class="attr">url</span>: <span class="string">&#x27;http://www.cbooo.cn/BoxOffice/GetHourBoxOffice&#x27;</span>,</span><br><span class="line">            &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">rankList</span> = res.<span class="property">data</span>.<span class="property">data2</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="安装到Chrome中"><a href="#安装到Chrome中" class="headerlink" title="安装到Chrome中"></a>安装到Chrome中</h2><p>从右上角菜单-&gt;更多工具-&gt;扩展程序可以进入插件管理页面，也可以直接在地址栏输入 <a href="chrome://extensions/">chrome:&#x2F;&#x2F;extensions</a> 访问。进入到管理页面后需要勾选<code>开发者模式</code>。然后会出现<code>加载已解压的扩展程序</code>的选项，导入插件就好了。</p>
<p><img src="/chrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/1.jpg"></p>
<h2 id="demo效果"><a href="#demo效果" class="headerlink" title="demo效果"></a>demo效果</h2><p><img src="/chrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/3.jpg"></p>
<h2 id="打包与发布"><a href="#打包与发布" class="headerlink" title="打包与发布"></a>打包与发布</h2><p>插件管理页面有一个打包的选项，然后会生成一个<code>.crx</code>文件，如果要发布到应用商店的话需要先登录Google账号，然后花5美元注册为开发者，就可以提交审核了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xzhzzz.github.io/2019/02/18/REST%E5%92%8CRESTful/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xzhzzz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="...">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ...">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/18/REST%E5%92%8CRESTful/" class="post-title-link" itemprop="url">REST和RESTful</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-18 23:15:42" itemprop="dateCreated datePublished" datetime="2019-02-18T23:15:42+08:00">2019-02-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-16 16:38:36" itemprop="dateModified" datetime="2022-12-16T16:38:36+08:00">2022-12-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是REST"><a href="#什么是REST" class="headerlink" title="什么是REST"></a>什么是REST</h2><p>REST全称是REpresentational State Transfer，通俗来讲就是：资源在网络中以某种表现形式进行状态转移。首次出现于2000年Roy Fielding的博士论文中，Roy Fielding是HTTP规范（1.0版和1.1版）的主要编写者之一。他在论文中提到：”我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。REST指的是一组架构约束条件和原则。” 如果一个架构符合REST的约束条件和原则，我们就称它为RESTful架构。</p>
<h4 id="REST原则"><a href="#REST原则" class="headerlink" title="REST原则"></a>REST原则</h4><ul>
<li>网络上的所有事物都被抽象为资源</li>
<li>每个资源都有一个唯一的资源标识符</li>
<li>同一个资源具有多种表现形式(xml，json等)</li>
<li>对资源的各种操作不会改变资源标识符</li>
<li>所有的操作都是无状态的</li>
</ul>
<h2 id="什么是RESTful"><a href="#什么是RESTful" class="headerlink" title="什么是RESTful"></a>什么是RESTful</h2><p>遵守了<strong>REST</strong>原则的Web服务</p>
<h2 id="二者的联系与区别"><a href="#二者的联系与区别" class="headerlink" title="二者的联系与区别"></a>二者的联系与区别</h2><p>RESTful是由REST派生出来的</p>
<h2 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h2><p>RESTful API可以通过一套统一的接口为 Web，iOS和Android提供一致的服务。</p>
<p><img src="/REST%E5%92%8CRESTful/1.jpg"></p>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul>
<li>URL的根路径（包含api标识）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://api.demo.com/v1</span><br></pre></td></tr></table></figure>

<ul>
<li>需要有api版本信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://api.demo.com/v1</span><br></pre></td></tr></table></figure>

<ul>
<li>URL中只使用名词指定资源，不用动词，且推荐使用复数</li>
</ul>
<p> 服务提供的RESTful API中，URL中只使用名词来指定资源，原则上不使用动词。“资源”是REST架构或者说整个网络处理的核心。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://api.demo.com/v1/cars // 获取某个账户下的车辆列表</span><br><span class="line">http://api.demo.com/v1/airplanes // 获取某个账户下的飞机列表</span><br></pre></td></tr></table></figure>

<ul>
<li>用HTTP协议里的动词来实现资源的添加，修改，删除等操作</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET 用于获取资源。</span><br><span class="line">POST 用于新建资源。</span><br><span class="line">DELETE 用于删除资源。</span><br><span class="line">PUT 用于更新资源。</span><br><span class="line">UPDATE 用于更新资源。</span><br><span class="line">PATCH 用于更新资源。</span><br></pre></td></tr></table></figure>

<ul>
<li>GET应该是安全的，不会改变资源状态</li>
</ul>
<p> GET的时候只是获取资源，而不涉及添加、更新、删除资源。</p>
<ul>
<li>使用正确的HTTP Status Code状态返回码</li>
</ul>
<p> 常用的有404，200，500，400等等。</p>
<ul>
<li>过滤信息</li>
</ul>
<p> 如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。<br>下面是一些常见的参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?limit=<span class="number">10</span> <span class="comment">// 指定返回记录的数量</span></span><br><span class="line">?offset=<span class="number">10</span> <span class="comment">// 指定返回记录的开始位置。</span></span><br><span class="line">?page=<span class="number">2</span>&amp;per_page=<span class="number">100</span> <span class="comment">// 指定第几页，以及每页的记录数。</span></span><br><span class="line">?sortby=name&amp;order=asc <span class="comment">// 指定返回结果按照哪个属性排序，以及排序顺序。</span></span><br><span class="line">?producy_type=<span class="number">1</span> <span class="comment">// 指定筛选条件</span></span><br></pre></td></tr></table></figure>

<ul>
<li>规范返回的数据</li>
</ul>
<p> 为了保障前后端的数据交互的顺畅，建议规范数据的返回，并采用固定的数据格式封装。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code: 0,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    msg: ’’</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，一个标准的RESTful API要可以做到，看Url就知道要操作的资源是什么；看Http Method就知道操作动作是什么，是添加（post）还是删除（delete）；看Http Status Code就知道操作结果如何，是成功（200）还是错误（500）；</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xzhzzz.github.io/2019/01/09/TCP%E5%92%8CUDP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xzhzzz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="...">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ...">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/09/TCP%E5%92%8CUDP/" class="post-title-link" itemprop="url">TCP和UDP</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-09 22:10:36" itemprop="dateCreated datePublished" datetime="2019-01-09T22:10:36+08:00">2019-01-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-16 16:38:36" itemprop="dateModified" datetime="2022-12-16T16:38:36+08:00">2022-12-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="TCP-x2F-IP五层网络结构模型"><a href="#TCP-x2F-IP五层网络结构模型" class="headerlink" title="TCP&#x2F;IP五层网络结构模型"></a>TCP&#x2F;IP五层网络结构模型</h2><ul>
<li>物理层：物理层建立在物理通信介质的基础上，作为系统和通信介质的接口，用来实现数据链路实体间透明的比特 (bit) 流传输。只有该层为真实物理通信，其它各层为虚拟通信</li>
<li>数据链路层:在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧（Frame）在信道上无差错的传输，并进行各电路上的动作系列。数据的单位称为帧（frame）</li>
<li>网络层：选择合适的路由，使数据分组（packet）可以交付到目的主机</li>
<li>传输层：负责主机中进程间的通信</li>
<li>应用层：直接为用户的应用程序提供服务</li>
</ul>
<h2 id="UDP详解"><a href="#UDP详解" class="headerlink" title="UDP详解"></a>UDP详解</h2><blockquote>
<p>用户数据报协议（英语：User Datagram Protocol，缩写为UDP），又称使用者资料包协定，是一个简单的面向数据报的传输层协议，正式规范为RFC 768。<br>在TCP&#x2F;IP模型中，UDP为网络层以上和应用层以下提供了一个简单的接口。UDP只提供数据的不可靠传递，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份（所以UDP有时候也被认为是不可靠的数据报协议）。UDP在IP数据报的头部仅仅加入了复用和数据校验（字段）。</p>
</blockquote>
<h4 id="UDP的优点"><a href="#UDP的优点" class="headerlink" title="UDP的优点"></a>UDP的优点</h4><ul>
<li>无需建立连接（减少延迟）</li>
<li>实现简单：无需维护连接状态</li>
<li>头部开销小（最小值为8byte）</li>
<li>没有拥塞控制：应用可以更好的控制发送时间和发送速率</li>
</ul>
<h4 id="UDP头部："><a href="#UDP头部：" class="headerlink" title="UDP头部："></a>UDP头部：</h4><p><img src="/TCP%E5%92%8CUDP/1.png"></p>
<p><img src="/TCP%E5%92%8CUDP/2.png"></p>
<p>UDP的头部是由源端口号、目标端口号、包长和校验4个部分组成，其中两个是可选的。各16bit的来源端口和目的端口用来标记发送和接受的应用进程。因为UDP不需要应答，所以来源端口是可选的，如果来源端口不用，那么置为零。在目的端口后面是长度固定的以字节为单位的长度域，用来指定UDP数据报包括数据部分的长度，长度最小值为8byte。首部剩下地16bit是用来对首部和数据部分一起做校验和Checksum的，Checksum主要是用来检测UDP段在传输中是否发生了错误。在校验和计算中也需要计算UDP伪头部，伪头部包含IP头部的一些字段。刚才介绍了识别一个通信需要4项信息，而UDP头部只有端口号，余下的三项在IP头部，所以引入了伪头部的概念。（IPv6的IP头部没有校验和字段）</p>
<h4 id="基于UDP协议的有："><a href="#基于UDP协议的有：" class="headerlink" title="基于UDP协议的有："></a>基于UDP协议的有：</h4><ul>
<li>域名系统（DNS）</li>
<li>简单网络管理协议（SNMP）</li>
<li>动态主机配置协议（DHCP）</li>
<li>路由信息协议（RIP）</li>
<li>自举协议（BOOTP）</li>
<li>简单文件传输协议（TFTP）</li>
</ul>
<h2 id="TCP详解"><a href="#TCP详解" class="headerlink" title="TCP详解"></a>TCP详解</h2><blockquote>
<p>传输控制协议（英语：Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。<br>在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。<br>应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和Checksum。</p>
</blockquote>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src="/TCP%E5%92%8CUDP/3.png"></p>
<p>TCP用三路握手（three-way handshake）过程创建一个连接。在连接创建过程中，很多参数要被初始化，例如序号被初始化以保证按序传输和连接的强壮性。</p>
<ul>
<li>客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三路握手的一部分。客户端把这段连接的序号设定为随机数A。</li>
<li>服务器端应当为一个合法的SYN回送一个SYN&#x2F;ACK。ACK的确认码应为A+1，SYN&#x2F;ACK包本身又有一个随机序号B。</li>
<li>最后，客户端再发送一个ACK。当服务端受到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号A+1，而响应则为B+1。</li>
</ul>
<h4 id="TCP状态编码"><a href="#TCP状态编码" class="headerlink" title="TCP状态编码"></a>TCP状态编码</h4><p>下表为TCP状态码列表，以S指代服务器，C指代客户端，S&amp;C表示两者，S&#x2F;C表示两者之一：</p>
<ul>
<li>LISTEN S<br>等待从任意远程TCP端口的连接请求。侦听状态。</li>
<li>SYN-SENT C<br>在发送连接请求后等待匹配的连接请求。通过connect()函数向服务器发出一个同步（SYNC）信号后进入此状态。</li>
<li>SYN-RECEIVED S<br>已经收到并发送同步（SYNC）信号之后等待确认（ACK）请求。</li>
<li>ESTABLISHED S&amp;C<br>连接已经打开，收到的数据可以发送给用户。数据传输步骤的正常情况。此时连接两端是平等的。</li>
<li>FIN-WAIT-1 S&amp;C<br>主动关闭端调用close（）函数发出FIN请求包，表示本方的数据发送全部结束，等待TCP连接另一端的确认包或FIN请求包。</li>
<li>FIN-WAIT-2 S&amp;C<br>主动关闭端在FIN-WAIT-1状态下收到确认包，进入等待远程TCP的连接终止请求的半关闭状态。这时可以接收数据，但不再发送数据。</li>
<li>CLOSE-WAIT S&amp;C<br>被动关闭端接到FIN后，就发出ACK以回应FIN请求，并进入等待本地用户的连接终止请求的半关闭状态。这时可以发送数据，但不再接收数据。</li>
<li>CLOSING S&amp;C<br>在发出FIN后，又收到对方发来的FIN后，进入等待对方对连接终止（FIN）的确认（ACK）的状态。</li>
<li>LAST-ACK S&amp;C<br>被动关闭端全部数据发送完成之后，向主动关闭端发送FIN，进入等待确认包的状态。</li>
<li>TIME-WAIT S&#x2F;C<br>主动关闭端接收到FIN后，就发送ACK包，等待足够时间以确保被动关闭端收到了终止请求的确认包。【按照RFC 793，一个连接可以在TIME-WAIT保证最大四分钟，即最大分段寿命（maximum segment lifetime）的2倍】</li>
<li>CLOSED S&amp;C<br>完全没有连接。</li>
</ul>
<h4 id="基于TCP实现的协议有"><a href="#基于TCP实现的协议有" class="headerlink" title="基于TCP实现的协议有"></a>基于TCP实现的协议有</h4><ul>
<li>HTTP&#x2F;HTTPS</li>
<li>Telnet</li>
<li>FTP</li>
<li>SMTP</li>
</ul>
<h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><ul>
<li>TCP是面向连接(Connection oriented)的协议，UDP是无连接(Connection less)协议；<br>TCP用三次握手建立连接：1) Client向server发送SYN；2) Server接收到SYN，回复Client一个SYN-ACK；3) Client接收到SYN_ACK，回复Server一个ACK。到此，连接建成。UDP发送数据前不需要建立连接。</li>
<li>TCP可靠，UDP不可靠；TCP丢包会自动重传，UDP不会。</li>
<li>TCP有序，UDP无序；消息在传输过程中可能会乱序，后发送的消息可能会先到达，TCP会对其进行重排序，UDP不会。</li>
<li>TCP无界，UDP有界；TCP通过字节流传输，UDP中每一个包都是单独的。</li>
<li>TCP有流量控制（拥塞控制），UDP没有；主要靠三次握手实现。</li>
<li>TCP传输慢，UDP传输快；因为TCP需要建立连接、保证可靠性和有序性，所以比较耗时。这就是为什么视频流、广播电视、在线多媒体游戏等选择使用UDP。</li>
<li>TCP是重量级的，UDP是轻量级的；TCP要建立连接、保证可靠性和有序性，就会传输更多的信息，如TCP的包头比较大。</li>
<li>TCP的头部比UDP大；TCP头部需要20字节，UDP头部只要8个字节。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xzhzzz.github.io/2018/12/09/%E4%BF%AE%E9%A5%B0%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xzhzzz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="...">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ...">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/12/09/%E4%BF%AE%E9%A5%B0%E5%99%A8/" class="post-title-link" itemprop="url">修饰器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-12-09 20:51:01" itemprop="dateCreated datePublished" datetime="2018-12-09T20:51:01+08:00">2018-12-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-16 16:38:36" itemprop="dateModified" datetime="2022-12-16T16:38:36+08:00">2022-12-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>修饰器（Decorator）是一个函数，用来修改类的行为。这是ES7的一个提案，目前Babel转码器已经支持，插件名babel-plugin-transform-decorators。熟悉使用修饰器将会简化代码编写，提高代码可读性。</p>
</blockquote>
<h3 id="类的修饰"><a href="#类的修饰" class="headerlink" title="类的修饰"></a>类的修饰</h3><ul>
<li>为类添加静态属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testable</span>(<span class="params">target</span>) &#123;</span><br><span class="line">	target.<span class="property">isTestable</span> = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTestableClass</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyTestableClass</span>.<span class="property">isTestable</span> <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面例子中，<code>@testable</code>就是一个修饰器。修饰器函数的第一个参数，就是所要修饰的目标类。它修改了<code>MyTestableClass</code>这个类的行为，为它加上了静态属性<code>isTestable</code>。<code>testable</code>函数的参数<code>target</code>是<code>MyTestableClass</code>类本身。</p>
<p>如果需要多个参数，可以使用高阶函数，在修饰器外面再封装一层函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testable</span>(<span class="params">isTestable</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">		target.<span class="property">isTestable</span> = isTestable</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="title function_">testable</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTestableClass</span> &#123;&#125;</span><br><span class="line"><span class="title class_">MyTestableClass</span>.<span class="property">isTestable</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">@<span class="title function_">testable</span>(<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;&#125;</span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property">isTestable</span> <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中，修饰器<code>testable</code>可以接受参数，这就等于可以修改修饰器的行为。</p>
<p>注意，修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。</p>
<ul>
<li>为实例添加属性</li>
</ul>
<p>前面的例子是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的<code>prototype</code>对象操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testable</span>(<span class="params">target</span>) &#123;</span><br><span class="line">	target.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">isTestable</span> = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTestableClass</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">MyTestableClass</span>()</span><br><span class="line">obj.<span class="property">isTestable</span> <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中，修饰器函数<code>testable</code>是在目标类的<code>prototype</code>对象上添加属性，因此就可以在实例上调用。</p>
<ul>
<li>为实例添加方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mixins</span>(<span class="params">...list</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target</span>) &#123;</span><br><span class="line">		<span class="title class_">Object</span>.<span class="title function_">assign</span>(target.<span class="property"><span class="keyword">prototype</span></span>, ...list)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="title function_">mixins</span>(<span class="title class_">Foo</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">MyClass</span>()</span><br><span class="line">obj.<span class="title function_">foo</span>() <span class="comment">// &#x27;foo&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码通过修饰器<code>mixins</code>，把<code>Foo</code>对象的方法添加到了<code>MyClass</code>的实例上面。</p>
<p>在React实际开发中，React 与 Redux 库结合使用时，常常需要写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyReactComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>(mapStateToProps, mapDispatchToProps)(<span class="title class_">MyReactComponent</span>)</span><br></pre></td></tr></table></figure>

<p>有了装饰器，就可以改写上面的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title function_">connect</span>(mapStateToProps, mapDispatchToProps)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">MyReactComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类属性的修饰"><a href="#类属性的修饰" class="headerlink" title="类属性的修饰"></a>类属性的修饰</h3><p>修饰器不仅可以修饰类，还可以修饰类的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    @readonly</span><br><span class="line">    <span class="title function_">name</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中，修饰器<code>readonly</code>用来修饰“类”的<code>name</code>方法。</p>
<p>修饰器函数<code>readonly</code>一共可以接受三个参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三个参数：descriptor对象原来的值如下</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// 		value: specifiedFunction,</span></span><br><span class="line"><span class="comment">//   	enumerable: false,</span></span><br><span class="line"><span class="comment">//   	configurable: true,</span></span><br><span class="line"><span class="comment">//  	writable: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readonly</span>(<span class="params">target, name, descriptor</span>)&#123;</span><br><span class="line">	descriptor.<span class="property">writable</span> = <span class="literal">false</span></span><br><span class="line">  	<span class="keyword">return</span> descriptor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">readonly</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;name&#x27;</span>, descriptor)</span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;name&#x27;</span>, descriptor)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修饰器第一个参数是类的原型对象，上面例子是<code>Person.prototype</code>，修饰器的本意是要“修饰”类的实例，但是这个时候实例还没生成，所以只能去修饰原型（这不同于类的修饰，那种情况时<code>target</code>参数指的是类本身）；第二个参数是所要修饰的属性名，第三个参数是该属性的描述对象。</p>
<p>另外，上面代码说明，修饰器（readonly）会修改属性的描述对象（descriptor），然后被修改的描述对象再用来定义属性。</p>
<p>下面是另一个例子，修改属性描述对象的<code>enumerable</code>属性，使得该属性不可遍历。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">nonenumerable</span>(<span class="params">target, name, descriptor</span>) &#123;</span><br><span class="line">  	descriptor.<span class="property">enumerable</span> = <span class="literal">false</span>;</span><br><span class="line">  	<span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  	@nonenumerable</span><br><span class="line">  	<span class="keyword">get</span> <span class="title function_">kidCount</span>() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">children</span>.<span class="property">length</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修饰器有注释的作用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  	@readonly</span><br><span class="line">  	@nonenumerable</span><br><span class="line">  	<span class="title function_">name</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.first&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.last&#125;</span>`</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面代码中，我们一眼就能看出，<code>Person</code>类是可测试的，而<code>name</code>方法是只读和不可枚举的。</p>
<ul>
<li>同一个方法多个修饰器，执行顺序，会像剥洋葱一样，先从外到内进入，然后由内向外执行。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dec</span>(<span class="params">id</span>)&#123;</span><br><span class="line">  	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;evaluated&#x27;</span>, id)</span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">target, property, descriptor</span>) &#123; </span><br><span class="line">      	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;executed&#x27;</span>, id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    @<span class="title function_">dec</span>(<span class="number">1</span>)</span><br><span class="line">    @<span class="title function_">dec</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="title function_">method</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// evaluated 1</span></span><br><span class="line"><span class="comment">// evaluated 2</span></span><br><span class="line"><span class="comment">// executed 2</span></span><br><span class="line"><span class="comment">// executed 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中，外层修饰器<code>@dec(1)</code>先进入，但是内层修饰器<code>@dec(2)</code>先执行。</p>
<h3 id="修饰器不能用于函数"><a href="#修饰器不能用于函数" class="headerlink" title="修饰器不能用于函数"></a>修饰器不能用于函数</h3><p>修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@add</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码，意图是执行后<code>counter</code>等于 1，但是实际上结果是<code>counter</code>等于 0。因为函数提升，使得实际执行的代码是下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@add</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter</span><br><span class="line"><span class="keyword">var</span> add</span><br><span class="line"></span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">add = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	counter++</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于存在函数提升，使得修饰器不能用于函数。类是不会提升的，所以就没有这方面的问题。</p>
<ul>
<li>如果一定要修饰函数，可以采用高阶函数的形式直接执行</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loggingDecorator</span>(<span class="params">wrapped</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Starting&#x27;</span>)</span><br><span class="line">		<span class="keyword">const</span> result = wrapped.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Finished&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> result</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapped = <span class="title function_">loggingDecorator</span>(doSomething)</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xzhzzz.github.io/2018/11/11/WebSocket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xzhzzz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="...">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ...">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/11/WebSocket/" class="post-title-link" itemprop="url">WebSocket</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-11 20:31:50" itemprop="dateCreated datePublished" datetime="2018-11-11T20:31:50+08:00">2018-11-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-16 16:38:36" itemprop="dateModified" datetime="2022-12-16T16:38:36+08:00">2022-12-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="WebSocket是什么？"><a href="#WebSocket是什么？" class="headerlink" title="WebSocket是什么？"></a>WebSocket是什么？</h3><p>WebSocket是用于在Web浏览器和服务器之间进行任意的双向数据传输的一种技术。WebSocket协议基于TCP协议实现，包含初始的握手过程，以及后续的多次数据帧双向传输过程。其目的是在WebSocket应用和WebSocket服务器进行频繁双向通信时，可以使服务器避免打开多个HTTP连接进行工作来节约资源，提高了服务器的工作效率和资源利用率。</p>
<h3 id="为什么会有WebSocket？"><a href="#为什么会有WebSocket？" class="headerlink" title="为什么会有WebSocket？"></a>为什么会有WebSocket？</h3><p>WebSocket 是为了满足基于 Web 的日益增长的实时通信需求而产生的</p>
<p>WebSocket出现之前在实时通信场景中的解决方法有： </p>
<ul>
<li>轮询：客户端设置一个定时请求，向服务器发送request询问有无新数据，服务器立即返回response，如果有更新则携带更新的数据。</li>
<li>长轮询（long poll）: 和轮询相似，但是为阻塞模式的轮询，客户端请求新的数据request，但服务器会阻塞请求，直到有新数据后才返回response给客户端；然后客户端再重复此过程。这两种方式的特点，不断的建立HTTP连接，然后发送请求request，之后服务器等待处理。服务端体现的是一种被动性，同时这种处理方式，非常耗费网络带宽和服务器资源。</li>
</ul>
<p>轮询需要服务器有很快的处理速度和资源。long poll需要有很高的并发，也就是说同时接待客户的能力。而且在服务器向客户端推送更新时，因为被动性，对低延迟的应用体验不好；而因为request&#x2F;response的交互方式，对网络带宽和服务器带来了额外的负担。而WebSocket的出现解决了这些问题。当服务器完成协议升级后（HTTP -&gt;Websocket），服务端就可以主动推送信息给客户端，解决了上面同步有延迟的问题。这就是为什么会有WebSocket技术的缘由。</p>
<h3 id="WebSocket与HTTP"><a href="#WebSocket与HTTP" class="headerlink" title="WebSocket与HTTP"></a>WebSocket与HTTP</h3><p>WebSocket是提供使用一个Tcp连接进行双向通讯的机制，包括网络协议和API，以取代网页和服务器采用HTTP轮询进行双向通讯的机制。</p>
<p>本质上来说，WebSocket是不限于HTTP协议的，但是由于现存大量的HTTP基础设施，代理，过滤，身份认证等等，WebSocket需要借用HTTP和HTTPS的端口。</p>
<p>由于使用HTTP的端口，因此TCP连接建立后的握手消息是基于HTTP的，由服务器判断这是一个HTTP协议，还是WebSocket协议。 WebSocket连接除了建立和关闭时的握手，其数据传输的过程和HTTP就没有关系了。</p>
<h3 id="WebSocket的使用"><a href="#WebSocket的使用" class="headerlink" title="WebSocket的使用"></a>WebSocket的使用</h3><p>WebSocket在客户端中的使用并不复杂。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> websocket = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 判断当前浏览器是否支持WebSocket</span></span><br><span class="line"><span class="comment">// http -&gt; ws     https -&gt; wss</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;WebSocket&#x27;</span> <span class="keyword">in</span> <span class="variable language_">window</span>) &#123;</span><br><span class="line">    websocket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://localhost:8080/websocket&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;当前浏览器 Not support websocket&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 连接发生错误的回调方法</span></span><br><span class="line">websocket.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebSocket连接发生错误&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 连接成功建立的回调方法</span></span><br><span class="line">websocket.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    websocket.<span class="title function_">send</span>(<span class="string">&#x27;发送数据&#x27;</span>); <span class="comment">// 客户端发送消息</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 接收服务端消息的回调方法</span></span><br><span class="line">websocket.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接关闭的回调方法</span></span><br><span class="line">websocket.<span class="property">onclose</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebSocket连接关闭&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onbeforeunload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    websocket.<span class="title function_">close</span>(); <span class="comment">// 客户端断开连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xzhzzz.github.io/2018/10/08/Node%E4%B8%AD%E7%9A%84fs%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xzhzzz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="...">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ...">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/10/08/Node%E4%B8%AD%E7%9A%84fs%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">Node中的fs模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-08 22:16:22" itemprop="dateCreated datePublished" datetime="2018-10-08T22:16:22+08:00">2018-10-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-16 16:38:36" itemprop="dateModified" datetime="2022-12-16T16:38:36+08:00">2022-12-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>Node中的fs（文件系统）模块是用于对系统文件及目录进行读写操作，fs模块提供了一些 API，用于以一种类似标准 POSIX 函数的方式与文件系统进行交互。</p>
</blockquote>
<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>fs模块中所有方法都有同步和异步两种形式。</p>
<p>异步方法中回调函数的第一个参数总是留给异常参数（exception），如果方法成功完成，该参数为null或undefined。</p>
<p>异步删除文件例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>); <span class="comment">// 载入fs模块</span></span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">unlink</span>(<span class="string">&#x27;/tmp/xxx&#x27;</span>, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功删除了 /tmp/xxx&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>同步删除文件例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>); <span class="comment">// 载入fs模块</span></span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">unlinkSync</span>(<span class="string">&#x27;/tmp/xxx&#x27;</span>); <span class="comment">// Sync表示是同步方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功删除了 /tmp/xxx&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>同步方法执行完并返回结果后，才能执行后续的代码。而异步方法采用回调函数接收返回结果，可以立即执行后续代码。</p>
<h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><p>使用fs.readFile(filename,[option],callback) 方法读取文件。</p>
<p>例子：</p>
<p>一个test.txt的文本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">line one</span><br><span class="line">line two</span><br></pre></td></tr></table></figure>

<p>readFile的回调函数接收两个参数，err是读取文件出错时触发的错误对象，data是从文件读取的数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>); <span class="comment">// 引入fs模块</span></span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./test.txt&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="comment">// 读取文件失败/错误</span></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取文件成功</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>js运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Buffer 6c 69 6e 65 20 6f 6e 65 0a 6c 69 6e 65 20 74 77 6f 0a&gt;</span><br></pre></td></tr></table></figure>

<p>这是原始二进制数据在缓冲区中的内容。</p>
<p>要显示文件内容可以使用toString()或者设置输出编码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用toString()</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./test.txt&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="comment">// 读取文件失败/错误</span></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取文件成功</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>设置utf-8编码写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置编码格式</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./test.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="comment">// 读取文件失败/错误</span></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取文件</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;utf-8: &#x27;</span>, data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>readFile的同步写法：fs.readFileSync(filename,[options])</p>
<h2 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h2><p>使用fs.writeFile(filename,data,[options],callback)写入内容到文件。</p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>); <span class="comment">// 引入fs模块</span></span><br><span class="line"><span class="comment">// 写入文件内容（如果文件不存在会创建一个文件）</span></span><br><span class="line"><span class="comment">// 写入时会先清空文件</span></span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;./test2.txt&#x27;</span>, <span class="string">&#x27;test test&#x27;</span>, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入成功后读取内容</span></span><br><span class="line">    fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./test2.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>因为改方法默认是写，会清空文件，如果是想要追加，可以传递一个flag参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>); <span class="comment">// 引入fs模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入文件内容（如果文件不存在会创建一个文件）</span></span><br><span class="line"><span class="comment">// 传递了追加参数 &#123; &#x27;flag&#x27;: &#x27;a&#x27; &#125; r代表读取文件，w代表写文件，a代表追加。</span></span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;./test2.txt&#x27;</span>, <span class="string">&#x27;test test&#x27;</span>, &#123; <span class="string">&#x27;flag&#x27;</span>: <span class="string">&#x27;a&#x27;</span> &#125;, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入成功后读取内容</span></span><br><span class="line">    fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./test2.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="使用fs-read和fs-write读写文件"><a href="#使用fs-read和fs-write读写文件" class="headerlink" title="使用fs.read和fs.write读写文件"></a>使用fs.read和fs.write读写文件</h2><p>fs.read和fs.write功能类似fs.readFile和fs.writeFile()，但提供<strong>更底层的操作</strong>，实际应用中多用fs.readFile和fs.writeFile。</p>
<p>使用fs.read和fs.write读写文件需要先使用fs.open打开文件和fs.close关闭文件。</p>
<h3 id="fs-read方法"><a href="#fs-read方法" class="headerlink" title="fs.read方法"></a>fs.read方法</h3><p><strong>fs.open(path,flags,[mode],callback)方法用于打开文件，以便fs.read()读取</strong></p>
<p>flags值及说明如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">r ：读取文件，文件不存在时报错；</span><br><span class="line">r+ ：读取并写入文件，文件不存在时报错；</span><br><span class="line">rs ：以同步方式读取文件，文件不存在时报错；</span><br><span class="line">rs+ ：以同步方式读取并写入文件，文件不存在时报错；</span><br><span class="line">w ：写入文件，文件不存在则创建，存在则清空；</span><br><span class="line">wx ：和w一样，但是文件存在时会报错；</span><br><span class="line">w+ ：读取并写入文件，文件不存在则创建，存在则清空；</span><br><span class="line">wx+ ：和w+一样，但是文件存在时会报错；</span><br><span class="line">a ：以追加方式写入文件，文件不存在则创建；</span><br><span class="line">ax ：和a一样，但是文件存在时会报错；</span><br><span class="line">a+ ：读取并追加写入文件，文件不存在则创建；</span><br><span class="line">ax+ ：和a+一样，但是文件存在时会报错。</span><br></pre></td></tr></table></figure>

<p><strong>fs.close(fd,[callback])</strong></p>
<p>用于关闭文件，fd是所打开文件的文件描述符。</p>
<p>fs.read(fd,buffer,offset,length,position,callback)接收6个参数。</p>
<p>参数说明：</p>
<ul>
<li>fd 文件描述符，必须接收fs.open()方法中的回调函数返回的第二个参数。</li>
<li>buffer 是存放读取到的数据的Buffer对象。</li>
<li>offset 指定 向buffer中存放数据的<strong>起始位置</strong>。</li>
<li>length 指定 读取文件中数据的<strong>字节数</strong>。</li>
<li>position 指定 在文件中读取文件内容的<strong>起始位置</strong>。</li>
<li>callback 回调函数，参数如下<ul>
<li>err 用于抛出异常</li>
<li>bytesRead 从文件中读取内容的<strong>实际字节数</strong>。</li>
<li>buffer 被读取的缓存区对象。</li>
</ul>
</li>
</ul>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>); <span class="comment">// 引入fs模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line">fs.<span class="title function_">open</span>(<span class="string">&#x27;./testread.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, fd</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="title class_">Buffer</span>(<span class="number">255</span>);</span><br><span class="line">    <span class="comment">// 读取文件</span></span><br><span class="line">    fs.<span class="title function_">read</span>(fd, buffer, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="keyword">function</span>(<span class="params">err, bytesRead, buffer</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印出buffer中存入的数据</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(bytesRead, buffer.<span class="title function_">slice</span>(<span class="number">0</span>, bytesRead).<span class="title function_">toString</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭文件</span></span><br><span class="line">        fs.<span class="title function_">close</span>(fd);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="fs-write方法"><a href="#fs-write方法" class="headerlink" title="fs.write方法"></a>fs.write方法</h3><p>fs.read(fd,buffer,offset,length[,position],callback(err,bytesWritten,buffer))接收6个参数。</p>
<p>参数说明：</p>
<ul>
<li>fd 文件描述符，必须接收fs.open()方法中的回调函数返回的第二个参数。</li>
<li>buffer 是存放 将被写入的数据，buffer尺寸的大小设置最好是8的倍数，效率较高。</li>
<li>offset  <strong>buffer写入的偏移量</strong>。</li>
<li>length (integer)指定 写入文件中数据的<strong>字节数</strong>。</li>
<li>position (integer) 指定 在写入文件内容的<strong>起始位置</strong>。</li>
<li>callback 回调函数，参数如下<ul>
<li>err 用于抛出异常</li>
<li>bytesWritten从文件中读取内容的<strong>实际字节数</strong>。</li>
<li>buffer 被读取的缓存区对象。</li>
</ul>
</li>
</ul>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>); <span class="comment">// 引入fs模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line">fs.<span class="title function_">open</span>(<span class="string">&#x27;./testwrite.txt&#x27;</span>, <span class="string">`w`</span>, <span class="keyword">function</span>(<span class="params">err, fd</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="title class_">Buffer</span>(<span class="string">&#x27;test test&#x27;</span>);</span><br><span class="line">    <span class="comment">// 读取文件</span></span><br><span class="line">    fs.<span class="title function_">write</span>(fd, buffer, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="keyword">function</span>(<span class="params">err, bytesWritten, buffer</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印出buffer中存入的数据</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(bytesWritten, buffer.<span class="title function_">slice</span>(<span class="number">0</span>, bytesWritten).<span class="title function_">toString</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭文件</span></span><br><span class="line">        fs.<span class="title function_">close</span>(fd);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>使用**fs.mkdir(path,[mode],callback)**创建目录，path是需要创建的目录，[mode]是目录的权限（默认是0777），callback是回调函数。</p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>); <span class="comment">// 引入fs模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 newdir 目录</span></span><br><span class="line">fs.<span class="title function_">mkdir</span>(<span class="string">&#x27;./newdir&#x27;</span>, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;make dir success.&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h3><p>使用fs.readdir(path,callback)读取文件目录。</p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>); <span class="comment">// 引入fs模块</span></span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readdir</span>(<span class="string">&#x27;./newdir&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, files</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// files是一个数组，每个元素是此目录下的文件或文件夹的名称</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(files);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h3><p>使用fs.rmdir(path,callback)读取文件目录。</p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="comment">// 执行前创建一个空的 /tmp/test 目录</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;准备删除目录 /tmp/test&quot;</span>);</span><br><span class="line">fs.<span class="title function_">rmdir</span>(<span class="string">&quot;/tmp/test&quot;</span>, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>fs模块还提供了许多文件操作的方法，本文只是介绍了基本的文件操作方法，对其他方法感兴趣的同学可以前往官方文档查阅。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xzhzzz.github.io/2018/09/09/Node%E4%B8%AD%E7%9A%84events%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xzhzzz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="...">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ...">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/09/09/Node%E4%B8%AD%E7%9A%84events%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">Node.js中的events模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-09 00:00:00" itemprop="dateCreated datePublished" datetime="2018-09-09T00:00:00+08:00">2018-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-16 16:38:36" itemprop="dateModified" datetime="2022-12-16T16:38:36+08:00">2022-12-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>大多数 Node.js 核心 API 都采用惯用的异步事件驱动架构，其中某些类型的对象（触发器）会周期性地触发命名事件来调用函数对象（监听器）。例如，<code>net.Server</code>对象会在每次有新连接时触发事件；<code>fs.ReadStream</code>会在文件被打开时触发事件；<code>流对象</code>会在数据可读时触发事件。</p>
</blockquote>
<p>events是Node.js 最重要的模块，Node.js中大部分的模块，都继承自events模块。与DOM树上事件不同，Node.js中的events不存在事件冒泡、逐层捕获等行为。events模块只提供<code>EventEmitter</code> 类。</p>
<h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><p>所有能触发事件的对象都是 <code>EventEmitter</code> 类的实例。当 <code>EventEmitter</code> 对象触发一个事件时，所有绑定在该事件上的函数都被同步地调用。 </p>
<p><code>eventEmitter.on(eventName, fn)</code> 方法注册监听器。</p>
<p><code>eventEmitter.emit(eventName, [arg1], [arg2], [...])</code> 方法手动触发监听器。</p>
<p><code>eventEmitter.once(eventName, fn)</code> 方法注册一个调用一次的监听器。 当事件被触发时，监听器会被注销，然后再调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EventEmitter</span> = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>();</span><br><span class="line"></span><br><span class="line">eventEmitter.<span class="title function_">on</span>(<span class="string">&#x27;event&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发了一个事件！&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">eventEmitter.<span class="title function_">emit</span>(<span class="string">&#x27;event&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m = <span class="number">0</span>;</span><br><span class="line">eventEmitter.<span class="title function_">once</span>(<span class="string">&#x27;eventOnce&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(++m);</span><br><span class="line">&#125;);</span><br><span class="line">eventEmitter.<span class="title function_">emit</span>(<span class="string">&#x27;eventOnce&#x27;</span>); <span class="comment">// 第一次调用：打印: 1</span></span><br><span class="line">eventEmitter.<span class="title function_">emit</span>(<span class="string">&#x27;eventOnce&#x27;</span>); <span class="comment">// 第二次调用：忽略</span></span><br></pre></td></tr></table></figure>

<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p><code>eventEmitter.removeListener(eventName, fn)</code> 方法是移除已注册的监听器。</p>
<p><code>eventEmitter.removeAllListeners ([eventName])</code> 方法移除所有或指定 eventName的监听器。</p>
<p><code>eventEmitter.setMaxListeners(n)</code> 方法设置最大监听数量。默认情况下，如果为特定事件添加了超过 10 个监听器，则 EventEmitter会打印一个警告。值设为 Infinit（或 0）表明不限制监听器的数量。如无必要，最好的不要去改变默认的监听数量限制。因为事件监听数量是node检测内存泄露的一个维度。EventEmitter实例的最大监听数量不是一个实例的所有监听数量。例如同一个实例A类型事件5个监听者，B类型事件6个监听者，这个并不会有告警。如果A类型有11个监听者，就会有告警提示。如果在事件中发现类似的告警提示<strong>Possible EventEmitter memory leak detected</strong>，要知道从事件最大监听数的角度去排查问题。</p>
<p><code>eventEmitter.getMaxListeners() </code> 方法返回 EventEmitter当前的最大监听器限制值。</p>
<p><code>eventEmitter.listenerCount(eventName)</code> 方法返回正在监听名为 eventName的事件的监听器的数量。</p>
<h3 id="错误事件处理"><a href="#错误事件处理" class="headerlink" title="错误事件处理"></a>错误事件处理</h3><p>当 <code>EventEmitter</code> 实例中发生错误时，会触发一个 <code>&#39;error&#39;</code> 事件。 这在 Node.js 中是特殊情况。</p>
<p>如果 <code>EventEmitter</code> 没有为 <code>&#39;error&#39;</code> 事件注册至少一个监听器，则当 <code>&#39;error&#39;</code> 事件触发时，会抛出错误、打印堆栈跟踪、且退出 Node.js 进程。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EventEmitter</span> = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>();</span><br><span class="line"></span><br><span class="line">eventEmitter.<span class="title function_">emit</span>(<span class="string">&#x27;error&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;whoops!&#x27;</span>));</span><br><span class="line"><span class="comment">// 抛出错误，并使 Node.js 崩溃</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了防止 Node.js 进程崩溃，应该始终为 <code>&#39;error&#39;</code> 事件注册监听器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EventEmitter</span> = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>();</span><br><span class="line"></span><br><span class="line">eventEmitter.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;有错误&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">eventEmitter.<span class="title function_">emit</span>(<span class="string">&#x27;error&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;whoops!&#x27;</span>));</span><br><span class="line"><span class="comment">// 打印: 有错误</span></span><br></pre></td></tr></table></figure>

<h3 id="利用events解决雪崩现象"><a href="#利用events解决雪崩现象" class="headerlink" title="利用events解决雪崩现象"></a>利用events解决雪崩现象</h3><p>雪崩问题就是在缓存失效后，并发访问量大量涌入数据库执行查询操作，导致数据库无法同时承受如此大的访问量，从而影响网站效果。</p>
<p><img src="/Node%E4%B8%AD%E7%9A%84events%E6%A8%A1%E5%9D%97/1.png" alt="img"></p>
<p><img src="/Node%E4%B8%AD%E7%9A%84events%E6%A8%A1%E5%9D%97/2.png" alt="img"></p>
<p>在 Node.js 中简单的数据库查询代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">select</span> = (<span class="params">callback</span>) =&gt; &#123;</span><br><span class="line">    db.<span class="title function_">select</span>(<span class="string">&#x27;SQL&#x27;</span>, <span class="function">(<span class="params">results</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">callback</span>(results);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上是一句数据库查询的调用，如果站点刚好启动，这时候缓存中是不存在数据的，而如果访问量巨大，同一句 SQL 会被发送到数据库中反复查询，影响到服务的整体性能。一个改进是添加一个状态锁。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">select</span> = (<span class="params">callback</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (status === <span class="string">&#x27;ready&#x27;</span>) &#123;</span><br><span class="line">        status = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">        db.<span class="title function_">select</span>(<span class="string">&#x27;SQL&#x27;</span>, <span class="function">(<span class="params">results</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">callback</span>(results);</span><br><span class="line">            status = <span class="string">&#x27;ready&#x27;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是这种情景，连续的多次调用 select，只有第一次调用是生效的，后续的 select 是没有数据服务的。所以这个时候引入事件队列：</p>
<p><img src="/Node%E4%B8%AD%E7%9A%84events%E6%A8%A1%E5%9D%97/3.png" alt="img"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EventEmitter</span> = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>();</span><br><span class="line"><span class="keyword">let</span> status = <span class="string">&#x27;ready&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">select</span> = (<span class="params">callback</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 将该实例的该操作放入队列，并且操作只执行一次</span></span><br><span class="line">    eventEmitter.<span class="title function_">once</span>(<span class="string">&#x27;selected&#x27;</span>, callback);</span><br><span class="line">    <span class="keyword">if</span> (status === <span class="string">&#x27;ready&#x27;</span>) &#123;</span><br><span class="line">        status = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">        db.<span class="title function_">select</span>(<span class="string">&#x27;SQL&#x27;</span>, <span class="function">(<span class="params">results</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 将该操作返回的数据作为回调函数的输入参数，执行回调函数</span></span><br><span class="line">            eventEmitter.<span class="title function_">emit</span>(<span class="string">&#x27;selected&#x27;</span>, results);</span><br><span class="line">            status = <span class="string">&#x27;ready&#x27;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码分析：<br>对于每一次查询，都会通过 once 方法订阅 selected 事件。当某个查询正在进行时，其他同时到达的查询处于 pending 状态，在订阅了 selected 事件后什么都不做，而请求的回调被压入事件队列中。当查询结束时，执行 emit 方法发布 selected 事件并更新状态。此时，那些订阅了 selected 事件的查询的回调函数被依次调用，并传入查询结果 results 作为参数。由于 once 方法的（执行一次就会将监视器移除）特点，每个查询的回调只会被执行一次。执行回调函数以后，由于 status 变为 ready，又可以响应其他的查询。</p>
<p>在这个过程中，对于相同的 SQL 语句，保证在同一个查询开始到结束的时间中永远只有一次，在这查询期间到来的相同查询，只需在队列中等待数据就绪即可。这些相同查询只是利用了这次查询的结果执行了回调而已，并没有查询数据库，节省了重复的数据库调用开销。</p>
<p>由于 Node.js 单线程执行的原因，此处无需担心状态问题。这种方式其实也可以应用到其他远程调用的场景中，即使外部没有缓存策略，也能有效节省重复开销。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xzhzzz.github.io/2018/08/04/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xzhzzz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="...">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ...">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/08/04/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">正则表达式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-04 17:48:44" itemprop="dateCreated datePublished" datetime="2018-08-04T17:48:44+08:00">2018-08-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-16 16:38:36" itemprop="dateModified" datetime="2022-12-16T16:38:36+08:00">2022-12-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="了解正则表达式"><a href="#了解正则表达式" class="headerlink" title="了解正则表达式"></a>了解正则表达式</h2><ul>
<li>什么是正则表达式<br>正则表达式(regular expression)是一个描述字符模式的对象。</li>
<li>为什么要使用正则表达式<br>正则表达式能够进行强大的“模式匹配”和“文本检索与替换”功能。前端往往有大量的表单数据校验的工作，采用正则表达式会使得数据校验的工作量大大减轻</li>
</ul>
<h2 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h2><h3 id="使用RegExp构造函数，"><a href="#使用RegExp构造函数，" class="headerlink" title="使用RegExp构造函数，"></a>使用RegExp构造函数，</h3><ul>
<li><p>第一个参数就是我们的模式“字符串”</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg= <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;study&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用特殊字符</span></span><br><span class="line"><span class="keyword">var</span> reg= <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;\\d\\w+&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>第二个参数可选，模式修饰符</p>
<ul>
<li>i: case-insensitive，表示忽略大小写</li>
<li>g: global，表示全局匹配</li>
<li>m: multiline，表示多行匹配</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = new RegExp(&#x27;study&#x27;, &#x27;ig&#x27;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="还可以用直接量方式直接声明"><a href="#还可以用直接量方式直接声明" class="headerlink" title="还可以用直接量方式直接声明"></a>还可以用直接量方式直接声明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /study/gi;</span><br></pre></td></tr></table></figure>

<ul>
<li>直接量是字符匹配，不支持变量</li>
</ul>
<h2 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h2><h3 id="支持正则表达式的字符串方法"><a href="#支持正则表达式的字符串方法" class="headerlink" title="支持正则表达式的字符串方法"></a>支持正则表达式的字符串方法</h3><ul>
<li>search<br>返回第一次匹配时所在的索引值,如果匹配不到则返回-1</li>
<li>match<ul>
<li>默认匹配字符串，返回一个数组<ul>
<li>0:所匹配的字符</li>
<li>index:匹配第一个字符所在的索引</li>
<li>input:对字符串的引用</li>
</ul>
</li>
<li>全局匹配(g)，返回一个匹配所有字符串数组</li>
<li>如果匹配不到则返回null</li>
</ul>
</li>
<li>replace<br>替换字符串</li>
<li>split<br><code>&#39;a, b, c, d, e&#39;.split(/\s*,\s* /);</code></li>
</ul>
<h3 id="正则表达式的属性和方法"><a href="#正则表达式的属性和方法" class="headerlink" title="正则表达式的属性和方法"></a>正则表达式的属性和方法</h3><ul>
<li><p>测试正则表达式用test方法,返回布尔值</p>
<ul>
<li>格式：正则表达式.test(字符串)</li>
<li>用&lt;正则表达式&gt;测试&lt;字符串&gt;是否匹配,返回true&#x2F;false</li>
</ul>
</li>
<li><p>测试正则表达式exec方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/xx/.exec(字符串)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h3><ul>
<li><p>所有字母和数字都是按照字面量进行匹配,和字符串匹配等效<br><code>/good/gi</code></p>
</li>
<li><p>字符类（只记小写字母即可）</p>
<ul>
<li><p>. : 除换行以外的字符</p>
</li>
<li><p>\w : 代表数字或字母或下划线</p>
</li>
<li><p>\W : 非数字字母和下划线字符</p>
</li>
<li><p>\d : 数字</p>
</li>
<li><p>\D : 非数字</p>
</li>
<li><p>\s : 代表一个空格</p>
</li>
<li><p>\S : 空格以外的字符</p>
</li>
<li><p>\b : 匹配一个单词边界，也就是指单词和空格间的位置</p>
</li>
<li><p>\B : 匹配非单词边界。</p>
<blockquote>
<p>PS:以上所有字符类都只是匹配“一个”字符</p>
</blockquote>
</li>
</ul>
</li>
<li><p>特殊符号</p>
<blockquote>
<p>^ $ . * + ? &#x3D; ! : | \ &#x2F; () [] {}</p>
</blockquote>
<ul>
<li><p>[]: 代表任意“单个字符” ,里面的内容表示“或”的关系</p>
<ul>
<li>-: 代表范围</li>
<li>^: 代表非</li>
</ul>
</li>
<li><p>(): 表示分组（n是以最左边括号出现的顺序排列）</p>
<ul>
<li><p>$1: 表示第一个分组</p>
</li>
<li><p>$n: 表示第n个分组（不能写在正则表达式里）</p>
</li>
<li><p>\n: 在正则分组后面使用，表示对第n个分组的引用(一定要写在正则表达式里)</p>
<blockquote>
<p>PS: 编写的正则分组数量越少越好</p>
</blockquote>
</li>
</ul>
</li>
<li><p>|: 表示或者</p>
</li>
<li><p>锚点定位</p>
<ul>
<li>^: 表示以什么开头</li>
<li>$: 表示以什么结尾</li>
</ul>
</li>
<li><p>表示数量，对前一个字符计数，</p>
<ul>
<li><p>*: 代表0个或0个以上 &lt;&#x3D;&#x3D;&#x3D;&gt;{0,}</p>
</li>
<li><p>+: 代表1个或1个以上 &lt;&#x3D;&#x3D;&#x3D;&gt;{1,}</p>
</li>
<li><p>?: 代表0个或1个 &lt;&#x3D;&#x3D;&#x3D;&gt;{0,1}</p>
</li>
<li><p>{}:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\d&#123;5&#125;: 匹配5个数字</span><br><span class="line">\d&#123;5,10&#125;: 匹配5个到10个数字</span><br><span class="line">\d&#123;5,&#125;: 匹配5个或5个以上的数字</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>PS:<br>1）数量词*,+,{5,}，会尽可能多的去匹配结果（贪婪）<br>2）在后面加一个?表示尽可能少的去匹配结果（非贪婪）<br>google,goooogle &#x3D;&#x3D;&gt; &#x2F;go+&#x2F;</p>
</blockquote>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xzhzzz.github.io/2018/07/07/dom%E6%93%8D%E4%BD%9C%E6%88%90%E6%9C%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xzhzzz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="...">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ...">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/07/07/dom%E6%93%8D%E4%BD%9C%E6%88%90%E6%9C%AC/" class="post-title-link" itemprop="url">dom操作成本</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-07-07 15:26:59" itemprop="dateCreated datePublished" datetime="2018-07-07T15:26:59+08:00">2018-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-16 16:38:36" itemprop="dateModified" datetime="2022-12-16T16:38:36+08:00">2022-12-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="DOM是什么"><a href="#DOM是什么" class="headerlink" title="DOM是什么"></a>DOM是什么</h3><blockquote>
<p>Document Object Model 文档对象模型</p>
</blockquote>
<p>可能很多人第一反应就是div、p、span等html标签。但要知道，DOM是Model，是Object Model，对象模型，是为HTML（and XML）提供的API。HTML(Hyper Text Markup Language)是一种标记语言，HTML在DOM的模型标准中被视为对象，DOM只提供编程接口，却无法实际操作HTML里面的内容。但在浏览器中，前端可以用JavaScript通过DOM去操作HTML。</p>
<p>那只有JavaScript可以操作HTML么？Python也是可以访问DOM。所以DOM不是提供给Javascript的API，也不是Javascript里的API。</p>
<blockquote>
<p>除了DOM，还存在CSSOM：CSS Object Model，浏览器将CSS代码解析成树形的数据结构，与DOM是两个独立的数据结构。</p>
</blockquote>
<h3 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h3><p>讨论DOM操作成本，肯定要先了解该成本的来源，那么就离不开浏览器渲染。</p>
<p>过程如下：</p>
<ol>
<li>解析HTML，构建DOM树（这里遇到外链，此时会发起请求）</li>
<li>解析CSS，生成CSS规则树</li>
<li>合并DOM树和CSS规则，生成render树</li>
<li>布局render树（Layout&#x2F;reflow），负责各元素尺寸、位置的计算</li>
<li>绘制render树（paint），绘制页面像素信息</li>
<li>浏览器会将各层的信息发送给GPU，GPU将各层合成（composite），显示在屏幕上</li>
</ol>
<h4 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h4><p>无论是DOM还是CSSOM，都是要经过 <code>Bytes → characters → tokens → nodes → objectmodel</code>这个过程。</p>
<p><img src="/dom%E6%93%8D%E4%BD%9C%E6%88%90%E6%9C%AC/dom1.png" alt="img"></p>
<blockquote>
<p>构建过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。</p>
</blockquote>
<h4 id="构建CSSOM树"><a href="#构建CSSOM树" class="headerlink" title="构建CSSOM树"></a>构建CSSOM树</h4><p>上述也提到了CSSOM的构建过程，也是树的结构，在最终计算各个节点的样式时，浏览器都会先从该节点的普遍属性（比如body里设置的全局样式）开始，再去应用该节点的具体属性。还有要注意的是，每个浏览器都有自己默认的样式表，因此很多时候这棵CSSOM树只是对这张默认样式表的部分替换。</p>
<h4 id="生成render树"><a href="#生成render树" class="headerlink" title="生成render树"></a>生成render树</h4><p>DOM树和CSSOM树合并生成render树</p>
<p>简单描述合并的过程：</p>
<p>DOM树从根节点开始遍历<strong>可见</strong>节点，这里之所以强调了“可见”，是因为如果遇到设置了类似 <code>display:none;</code>的不可见节点，在render过程中是会被跳过的（但 <code>visibility:hidden;opacity:0</code>这种仍旧占据空间的节点不会被跳过render），保存各个节点的样式信息及其余节点的从属关系。</p>
<h4 id="Layout-布局"><a href="#Layout-布局" class="headerlink" title="Layout 布局"></a>Layout 布局</h4><p>有了各个节点的样式信息和属性，但不知道各个节点的确切位置和大小，所以要通过布局将样式信息和属性转换为实际可视窗口的相对大小和位置。</p>
<h4 id="Paint-绘制"><a href="#Paint-绘制" class="headerlink" title="Paint 绘制"></a>Paint 绘制</h4><p>最后只要将确定好位置大小的各节点，通过GPU渲染到屏幕的实际像素。</p>
<h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><ul>
<li>在上述渲染过程中，前3点可能要多次执行，比如js脚本去操作dom、更改css样式时，浏览器又要重新构建DOM、CSSOM树，重新render，重新layout、paint；</li>
<li>Layout在Paint之前，因此每次Layout重新布局（reflow 回流）后都要重新出发Paint渲染，这时又要去消耗GPU；</li>
<li>Paint不一定会触发Layout，比如改个颜色改个背景；（repaint 重绘）</li>
<li>图片下载完也会重新出发Layout和Paint；</li>
</ul>
<p><img src="/dom%E6%93%8D%E4%BD%9C%E6%88%90%E6%9C%AC/dom2.png" alt="img"></p>
<h3 id="何时触发reflow和repaint"><a href="#何时触发reflow和repaint" class="headerlink" title="何时触发reflow和repaint"></a>何时触发reflow和repaint</h3><p>**reflow(回流)**：根据Render Tree布局，意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树</p>
<p>**repaint(重绘)**：意味着元素发生的改变只影响了节点的一些样式（背景色，边框颜色，文字颜色等），只需要应用新样式绘制这个元素就可以了</p>
<p>reflow回流的成本开销要高于repaint重绘，一个节点的回流往往回导致子节点以及同级节点的回流；</p>
<h4 id="引起reflow"><a href="#引起reflow" class="headerlink" title="引起reflow"></a>引起reflow</h4><p>现代浏览器会对回流做优化，它会等到足够数量的变化发生，再做一次批处理回流。</p>
<ol>
<li>页面第一次渲染（初始化）</li>
<li>DOM树变化（如：增删节点）</li>
<li>Render树变化（如：padding改变）</li>
<li>浏览器窗口resize</li>
<li>获取元素的某些属性</li>
</ol>
<p>浏览器为了获得正确的值也会<strong>提前触发回流</strong>，这样就使得浏览器的优化失效了，这些属性包括offsetLeft、offsetTop、offsetWidth、offsetHeight、 scrollTop&#x2F;Left&#x2F;Width&#x2F;Height、clientTop&#x2F;Left&#x2F;Width&#x2F;Height、调用了getComputedStyle()或者IE的currentStyle。</p>
<h4 id="引起repaint"><a href="#引起repaint" class="headerlink" title="引起repaint"></a>引起repaint</h4><ol>
<li>reflow回流必定引起repaint重绘，重绘可以单独触发</li>
<li>背景色、颜色、字体改变（字体大小发生变化时，会触发回流）</li>
</ol>
<h4 id="如何减少reflow、repaint触发次数"><a href="#如何减少reflow、repaint触发次数" class="headerlink" title="如何减少reflow、repaint触发次数"></a>如何减少reflow、repaint触发次数</h4><ul>
<li>避免逐个修改节点样式，尽量一次性修改</li>
<li>使用DocumentFragment将需要多次修改的DOM元素缓存，最后一次性append到真实DOM中渲染</li>
<li>可以将需要多次修改的DOM元素设置 <code>display :none</code>，操作完再显示。（因为隐藏元素不在render树内，因此修改隐藏元素不会触发回流重绘）</li>
<li>避免多次读取某些属性</li>
<li>将复杂的节点元素脱离文档流，降低回流成本</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>操作DOM具体的成本，说到底是造成浏览器回流reflow和重绘reflow，从而消耗GPU资源。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xzhzzz.github.io/2018/06/06/Electron%E5%88%9D%E4%BD%93%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xzhzzz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="...">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ...">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/06/06/Electron%E5%88%9D%E4%BD%93%E9%AA%8C/" class="post-title-link" itemprop="url">Electron初体验</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-06-06 10:57:08" itemprop="dateCreated datePublished" datetime="2018-06-06T10:57:08+08:00">2018-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-16 16:38:36" itemprop="dateModified" datetime="2022-12-16T16:38:36+08:00">2022-12-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Electron是什么？"><a href="#Electron是什么？" class="headerlink" title="Electron是什么？"></a>Electron是什么？</h3><p><a target="_blank" rel="noopener" href="https://electronjs.org/">ELectron</a>是使用 JavaScript, HTML 和 CSS 构建跨平台的桌面应用。</p>
<p>Electron通过结合Chromium和Node.js，使得应用程序可以在Mac，Windows和Linux上运行。Electron最开始是2013年GitHub上的文本编辑器Atom中的一个框架，并且在2014年开源。</p>
<table>
<thead>
<tr>
<th>日期</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>2013年4月</td>
<td>Atom Shell启动</td>
</tr>
<tr>
<td>2014年5月</td>
<td>Atom Shell</td>
</tr>
<tr>
<td>2015年4月</td>
<td>Atom Shell被更名为Electron</td>
</tr>
<tr>
<td>2016年5月</td>
<td>Electron发布v1.0.0版本</td>
</tr>
<tr>
<td>2016年5月</td>
<td>Electron应用兼容Mac App Store</td>
</tr>
<tr>
<td>2016年8月</td>
<td>Electron应用兼容Windows Store</td>
</tr>
</tbody></table>
<p>Electron调用在package.json中定义的main文件并执行。main文件（通常被命名为main.js）会创建一个内含渲染完的web页面的应用窗口，并添加与操作系统的原生GUI（图形界面）交互的功能。当用Electron启动一个应用，会创建一个主进程。这个主进程负责与系统原生的GUI进行交互并为你的应用创建GUI。</p>
<h3 id="Electron快速启动"><a href="#Electron快速启动" class="headerlink" title="Electron快速启动"></a>Electron快速启动</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 克隆示例项目的仓库</span><br><span class="line">$ git clone https://github.com/electron/electron-quick-start</span><br><span class="line"></span><br><span class="line"># 进入这个仓库</span><br><span class="line">$ cd electron-quick-start</span><br><span class="line"></span><br><span class="line"># 安装依赖并运行</span><br><span class="line">$ npm install &amp;&amp; npm start</span><br></pre></td></tr></table></figure>

<h3 id="主进程和渲染进程"><a href="#主进程和渲染进程" class="headerlink" title="主进程和渲染进程"></a>主进程和渲染进程</h3><h4 id="主进程"><a href="#主进程" class="headerlink" title="主进程"></a>主进程</h4><p>Electron 运行 <code>package.json</code> 的 <code>main</code> 脚本的进程被称为<strong>主进程</strong>。 在主进程中运行的脚本通过创建web页面来展示用户界面。 一个 Electron 应用总是有且只有一个主进程。在主进程里跑的脚本可以通过创建web页面的窗口来扮演GUI角色。</p>
<h4 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h4><p>由于 Electron 使用了 Chromium 来展示 web 页面，所以 Chromium 的多进程架构也被使用到。 每个 Electron 中的 web 页面运行在它自己的<strong>渲染进程</strong>中。</p>
<p>在普通的浏览器中，web页面通常在一个沙盒环境中运行，不被允许去接触原生的资源。 然而 Electron 的用户在 Node.js 的 API 支持下可以在页面中和操作系统进行一些底层交互。</p>
<h4 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h4><p>主进程使用 <code>BrowserWindow</code> 实例创建页面。 每个 <code>BrowserWindow</code> 实例都在自己的渲染进程里运行页面。 当一个 <code>BrowserWindow</code> 实例被销毁后，相应的渲染进程也会被终止。</p>
<p>主进程管理所有的web页面和它们对应的渲染进程。 每个渲染进程都是独立的，它只关心它所运行的 web 页面。</p>
<p>在页面中调用与 GUI 相关的原生 API 是不被允许的。 如果你想在 web 页面里使用 GUI 操作，其对应的渲染进程必须与主进程进行通讯，请求主进程进行相关的 GUI 操作。</p>
<p>在 Electron 中, 我们有几种方法可以在主进程和渲染进程之间进行通信。 例如使用<a target="_blank" rel="noopener" href="https://electronjs.org/docs/api/ipc-renderer"><code>ipcRenderer</code></a>和<a target="_blank" rel="noopener" href="https://electronjs.org/docs/api/ipc-main"><code>ipcMain</code></a>模块发送消息，或使用<a target="_blank" rel="noopener" href="https://electronjs.org/docs/api/remote"><code>remote</code></a>模块进行通信。</p>
<p><img src="/Electron%E5%88%9D%E4%BD%93%E9%AA%8C/main.png"></p>
<p>主进程 main.js：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; app, <span class="title class_">BrowserWindow</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mainWindow = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createWindow</span> () &#123;</span><br><span class="line">    <span class="comment">// 创建一个浏览窗口</span></span><br><span class="line">    mainWindow = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">        <span class="attr">icon</span>: __dirname + <span class="string">&#x27;/images/favicon.ico&#x27;</span>, </span><br><span class="line">        <span class="attr">width</span>: <span class="number">1200</span>, </span><br><span class="line">        <span class="attr">height</span>: <span class="number">600</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 加载页面资源</span></span><br><span class="line">    mainWindow.<span class="title function_">loadURL</span>(url.<span class="title function_">format</span>(&#123;</span><br><span class="line">        <span class="attr">pathname</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;index.html&#x27;</span>), </span><br><span class="line">        <span class="attr">protocol</span>: <span class="string">&#x27;file:&#x27;</span></span><br><span class="line">    &#125;))</span><br><span class="line">    <span class="comment">// 打开调试工具</span></span><br><span class="line">    mainWindow.<span class="property">webContents</span>.<span class="title function_">openDevTools</span>()；</span><br><span class="line">    <span class="comment">// 当浏览窗口关闭时调用</span></span><br><span class="line">    mainWindow.<span class="title function_">on</span>(<span class="string">&#x27;closed&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      mainWindow = <span class="literal">null</span>； </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">on</span>(<span class="string">&#x27;ready&#x27;</span>, createWindow);</span><br></pre></td></tr></table></figure>

<p><strong>mian.js代码中用到的ElectronApi</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://electronjs.org/docs/api/app">app</a></li>
<li><a target="_blank" rel="noopener" href="https://electronjs.org/docs/api/browser-window">BrowserWindow</a></li>
</ul>
<h3 id="Electron-打包"><a href="#Electron-打包" class="headerlink" title="Electron 打包"></a>Electron 打包</h3><p> 这里主要是使用<a target="_blank" rel="noopener" href="https://github.com/electron-userland/electron-builder">electron-builder</a> 来完成打包的任务。</p>
<p>第一步：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install electron-builder -g //全局安装electron-builder</span><br><span class="line"></span><br><span class="line">electron-builder --version //安装完成后输入一下指令如果可以查看到版本就证明安装成功</span><br></pre></td></tr></table></figure>

<p>第二步：</p>
<p>在Electron项目文件夹下的package.json文件中添加electron-builder编译的配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;build&quot;: &#123;</span><br><span class="line">    &quot;appId&quot;: &quot;com.demo&quot;, //包名称</span><br><span class="line">    &quot;copyright&quot;:&quot;demo&quot;, //版权设置</span><br><span class="line">    &quot;productName&quot;:&quot;electron-demo&quot;, //项目名称</span><br><span class="line">    &quot;win&quot;: &#123;</span><br><span class="line">      &quot;icon&quot;: &quot;images/app.ico&quot; //应用图标的路径，尺寸256*256</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>第三步：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">electron-builder --win --x64 //这里生成的是win系统64位的包</span><br><span class="line"></span><br><span class="line">electron-builder --help //可以使用该指令来查看全部相关的指令</span><br></pre></td></tr></table></figure>

<p>第四步：</p>
<p>如果打包成功后，项目下会生成一个dist的文件夹，里面就是已经打包好的程序以及相关系统文件。</p>
<h3 id="Electron-Vue"><a href="#Electron-Vue" class="headerlink" title="Electron+Vue"></a>Electron+Vue</h3><p>如果想在开发Electron应用是使用Vue可以使用 <a target="_blank" rel="noopener" href="https://github.com/SimulatedGREG/electron-vue">electron-vue</a> 快速构建工具。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装相关包</span><br><span class="line">npm install -g vue-cli</span><br><span class="line">vue init simulatedgreg/electron-vue my-project</span><br><span class="line"></span><br><span class="line"># 安装项目相关依赖</span><br><span class="line">cd my-project</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p>electron-vue 利用 <code>vue-cli</code> 作为脚手架工具，加上拥有 <code>vue-loader</code> 的 <code>webpack</code>、<code>electron-builder</code>，以及一些最常用的插件，如<code>vue-router</code>、<code>vuex</code> 等。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xzhzzz</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
